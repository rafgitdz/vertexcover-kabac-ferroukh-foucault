VertexCover release Note :

C'est quoi VertexCover ?
========================
VertexCover est une application open-source écrite en C++ avec Eclipse et Netbeans comme IDE, elle permet de résoudre le problème de couverture par sommets des graphes. Ce projet est sous la licence GPL http://www.gnu.org/licenses/gpl.html .

Pré-requis système 
==================
VertexCover est destinée à une execution sur un systéme Linux.

L'installation de l'application open-source GraphViz qui contient dot est nécéssaire pour le dessin des graphes. On peut télécharger l'application sur : http://www.graphviz.org/Download..php

Modules installés : l'application Minisat est contenu dans le projet, la version présente est la 1.4.

Comment installer ?
===================
L'installation de VertexCover se fait en suivant les étapes suivantes :

1. Décompresser le contenu de l'archive dans un répetoire donné.
2. Se mettre sous le répertoire VertexCover.
3. Exécuter le makefile en lançant la commande "make all" dans une console.
4. Lancer VertexCover avec la commande ''./VertexCover [Input_File] [options]'' (voir manuel utilisateur pour les détails).

Post-Installation
=================
Pour s'assurer que VertexCover fonctionne normalement, se mettre dans le répertoire "VertexCover" et lancer ./VertexCover -t

Lancement des programmes
========================
Consulter la manuel d'utilisation se trouvant à la racine du programme (répertoire VertexCover)

Lancement des tests
===================
Pour lancer les tests, il faut se placer sous le répertoire VertexCover/scripts. Un test est écrit en bash.

Note : Le sommet avec un numéro '0' (Zéro) n'est pas considéré dans la génération (import et export) des graphes.

Test de génération 
==================

Le script ''generation.sh'' englobe le test de génération de graphes et contient :
(il est à noter qu'a chaque itération, on créer un nouveau graphe).

Test de Comparaison sur le temps d'exécution entre le Graphe simple, le Graphe Bipartite et le Graphe avec une couverture minimale. 
*************************************************************************************************************************************

Nombre maximal sommets est égale à 10000.
Augmentation d'un taux de 100 sommets à chaque itération
Probabilité de création d'une arête entre deux sommets fixée à 0.4
Ratio de contenance de sommets des deux parties du Graphe Bipartite fixé à 0.5

* Test d'analyse du temps d'exécution de la création du Graphe avec couverture minimale 
***************************************************************************************

Nombre maximal de sommets fixé à 3000
Augementation d'un taux de 10 (en partant de 10) le nombre minimal de la couverture.

* Test d'analyse sur le temps d'exécution de la création d'un arbre (largeur) 
******************************************************************************

Nombre maximale de sommets fixé à 30000.
Augementation d'un taux de 100 sommets à chaque itération, en partant de 0.
Fixer le nombre de sommets fils à ''nombre_sommets/ 10'' à chaque itération.

* Test d'analyse sur le temps d'exécution de la création d'un graphe bipartit
*******************************************************************************

Nombre maximale de sommets fixé à 3000
Probabilité de création d'une arête entre deux sommets égale à 0.5
Variation du ratio part de 0.5 à 1, avec une augementation d'un taux de 0.5 à chaque itération

Test de recherche de couverture par sommets
===========================================

Le script "small_cover.sh" englobe tous les tests concernant la recherche de couverture sur un graphe avec couverture minimale.
Il contient :

* Test de comparaison entre 4 algorithmes de recherche de couverture sur un graphe avec couverture minimale  
************************************************************************************************************
(Variation de la probabilité de création d'une arête)

Nombre de sommets est égal à 3000
Taille couverture du graphe fixé a 300
Variation de la probabilité de création d'une arête de 5 à 100 avec augementation d'un taux de 5 à chaque itération

Algorithmes testés : Algorithme "cover edges", Algorithme "glouton", Algorithme "glouton simple", Algorithme "recherche en profondeur".

* Test de comparaison entre 4 algorithmes de recherche de couverture sur un graphe avec couverture minimale  
************************************************************************************************************
(Variation du nombre total de sommets du graphe)

Probabilité de création d'une arête entre deux sommets fixée à 40.
Taille couverture du graphe fixé a 100
Variation du nombre total de sommets de 100 à 3000 avec augementation d'un taux de 100 à chaque itération

Algorithmes testés : Algorithme "cover edges", Algorithme "glouton", Algorithme "glouton simple", Algorithme "recherche en profondeur".

* Test de comparaison entre 4 algorithmes de recherche de couverture sur un graphe avec couverture minimale
************************************************************************************************************
(Variation de la taille de la couverture à créer dans le graphe)

Nombre de sommets est égal à 3000
Probabilité de création d'une arête entre deux sommets fixée à 40.
Variation de la taille de la couverture de 100 à 3000 avec augementation d'un taux de 100 à chaque itération

Algorithmes testés : Algorithme "cover edges", Algorithme "glouton", Algorithme "glouton simple", Algorithme "deep search".

* Test de comparaison entre 5 algorithmes de recherche de couverture sur un arbre
*********************************************************************************

* Arbre large 

Nombre de sommets fixé à 10000
Nombre minumum de fils varie de de 2 à 100
Nombre maximum de fils  égal à 2*Min

Algorithmes testés : Algorithme "cover edges", Algorithme "glouton", Algorithme "glouton simple", Algorithme "deep search",
Algorithme "Optimal pour les arbres".

* Arbre profond

Nombre de sommets varie de 10 à 10010 avec augmentation d'un taux de 200 à chaque itération
Nombre minumum de fils fixé à 2
Nombre maximum de fils  fixé à 4

Algorithmes testés : Algorithme "cover edges", Algorithme "glouton", Algorithme "glouton simple", Algorithme "deep search",
Algorithme "Optimal pour les arbres".

* Test de l'algorithme de recherche "paramétrique" sur un graphe avec couverture minimale
******************************************************************************************

Nombre de sommets fixé à 100
Probabilité de créer une arête fixé à 0.4
La taille de la couverture du graphe créé varie de 5 à 20 (pas de 1).

Algorithme testé : Alogrithme paramétrique itératif et Alogrithme paramétrique récursif

* Test de comparaison entre 5 algorithmes de recherche de couverture sur un graphe bipartite avec couverture minimale
*********************************************************************************************************************
(Variation de la probabilité de création d'une arête)

Nombre de sommets fixé à 500
Taille de la couverture fixé à 100
Ratio de la couverture fixé à 20
Ratio part du bipartit fixé à 20
Variation de de la probabilité de création d'une arête de 1 à 100 avec une augmentation de 5 à chaque itération

Algorithmes testés : Algorithme "cover edges", Algorithme "glouton", Algorithme "glouton simple", Algorithme "deep search",
Algorithme "Optimal pour les graphes bipartit".

* Test de comparaison entre 5 algorithmes de recherche de couverture sur un graphe bipartite avec couverture minimale
*********************************************************************************************************************
(Variation de la du ration part du graph bipartite)

Nombre de sommets fixé à 500
Taille de la couverture fixé à 100
Ratio de la couverture fixé à 50
Probabilité de création d'une arête fixé à 15
Variation du ratio part de 5 à 95 avec une augmentation de 5 à chaque itération

Algorithmes testés : Algorithme "cover edges", Algorithme "glouton", Algorithme "glouton simple", Algorithme "deep search",
Algorithme "Optimal pour les graphes bipartit".

* Test de comparaison entre 5 algorithmes de recherche de couverture sur un graphe bipartite avec couverture minimale
*********************************************************************************************************************
(Variation de la probabilité de création d'une arête)

Taille de la couverture fixé à 200
Ratio de la couverture fixé à 20
Ratio part du bipartit fixé à 20
Probabilité de création d'une arête fixé à 15
Variation du nombre de sommets total du graphe de 100 à 1000 avec une augmentation de 50 à chaque itération

Algorithmes testés : Algorithme "cover edges", Algorithme "glouton", Algorithme "glouton simple", Algorithme "deep search",
Algorithme "Optimal pour les graphes bipartit".

* Test de comparaison entre 5 algorithmes de recherche de couverture sur un graphe bipartite avec couverture minimale
*********************************************************************************************************************
(Variation de la probabilité de création d'une arête)

Nombre de sommets fixé à 500
Taille de la couverture fixé à 200
Ratio part du bipartit fixé à 20
Probabilité de création d'une arête fixé à 15
Variation du ratio de la couverture entre les sommets du graphe de 10 à 90 avec une augmentation de 1 à chaque itération

Algorithmes testés : Algorithme "cover edges", Algorithme "glouton", Algorithme "glouton simple", Algorithme "deep search",
Algorithme "Optimal pour les graphes bipartit".

* Test de comparaison entre 5 algorithmes de recherche de couverture sur un arbre 
**********************************************************************************

Nombre de fils par sommet fixé à 1
Variation du nombre total de sommets de 100 à 16000 avec augmentation d'un taux de 100 à chaque itération

Algorithmes testés : Algorithme "cover edges", Algorithme "glouton", Algorithme "glouton simple", Algorithme "deep search",
Algorithme "Optimal pour les arbres".

Web site projet VertexCover
===========================
Ici on retrouvera le projet en format zip, on pourra voir les sources, les analyser, compiler et exécuter 
et apporter de nouveaux algorithmes pour une meilleur utilisation. Le report des bugs est à envoyer aux e-mails cités dans contact.

http://milan.kabac.emi.u-bordeaux1.fr/ 

http://matthieu.foucault.emi.u-bordeaux1.fr/
 
http://rafik.ferroukh.emi.u-bordeaux1.fr/ 

Contact
=======
Milan Kabac - milan.kabac@etu.u-bordeaux1.fr
Matthieu Foucault - matthieu.foucault@etu.u-bordeaux1.fr
Rafik Ferroukh - rafik.ferroukh@etu.u-bordeaux1.fr

Etudiants Master 2 - Génie Logiciel - 
Université Bordeaux 1
2011 - 2012



